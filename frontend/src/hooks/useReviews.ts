import { useCallback } from 'react';
import { useAppDispatch, useAppSelector } from './redux';
import { reviewsService, ReviewsError } from '../services/reviewsService';
import {
  setLoading,
  setSubmitting,
  setError,
  clearError,
  setTourReviews,
  setUserReviews,
  addUserReview,
  updateUserReview,
  removeUserReview,
  setCurrentReview,
  clearCurrentReview,
  clearTourReviews,
} from '../store/slices/reviewsSlice';
import { updateUserBookingStatus } from '../store/slices/bookingsSlice';
import type { CreateReviewData, UpdateReviewData, Review, ReviewWithTourInfo } from '../types/review';

export const useReviews = () => {
  const dispatch = useAppDispatch();
  
  // Select state from Redux
  const reviewsState = useAppSelector((state) => state.reviews);
  const toursState = useAppSelector((state) => state.tours);
  const bookingsState = useAppSelector((state) => state.bookings); // üîÑ Add bookings state

  // üîÑ Helper function to find booking by tour ID
  const findBookingByTourId = useCallback((tourId: string) => {
    return bookingsState.userBookings.find(booking => booking.tourId === tourId);
  }, [bookingsState.userBookings]);

  // üìñ Load reviews for a specific tour (Tour Detail Page)
  const loadTourReviews = useCallback(async (tourId: string) => {
    // Check if already loaded
    if (reviewsState.tourReviews[tourId]?.length > 0) {
      console.log(`üìÑ Reviews already loaded for tour ${tourId}`);
      return { success: true };
    }

    dispatch(setLoading(true));
    dispatch(clearError());

    try {
      console.log(`üìÑ useReviews: Loading reviews for tour ${tourId}...`);
      
      const reviews = await reviewsService.fetchTourReviews(tourId);
      
      dispatch(setTourReviews({ tourId, reviews }));
      dispatch(setLoading(false));
      
      console.log(`‚úÖ useReviews: Successfully loaded ${reviews.length} reviews for tour ${tourId}`);
      return { success: true };
      
    } catch (error) {
      console.error(`üö® useReviews: Failed to load reviews for tour ${tourId}:`, error);
      
      const errorMessage = error instanceof ReviewsError 
        ? error.message 
        : 'Failed to load reviews. Please try again.';
        
      dispatch(setError(errorMessage));
      dispatch(setLoading(false));
      
      return { success: false, error: errorMessage };
    }
  }, [dispatch, reviewsState.tourReviews]);

  // üë§ Load user's own reviews (User Profile Page)
  const loadUserReviews = useCallback(async () => {

    dispatch(setLoading(true));
    dispatch(clearError());

    try {
      console.log('üìÑ useReviews: Loading user reviews...');
      
      const reviews = await reviewsService.fetchUserReviews();
      
      dispatch(setUserReviews(reviews));
      dispatch(setLoading(false));
      
      console.log(`‚úÖ useReviews: Successfully loaded ${reviews.length} user reviews`);
      return { success: true };
      
    } catch (error) {
      console.error('üö® useReviews: Failed to load user reviews:', error);
      
      const errorMessage = error instanceof ReviewsError 
        ? error.message 
        : 'Failed to load your reviews. Please try again.';
        
      dispatch(setError(errorMessage));
      dispatch(setLoading(false));
      
      return { success: false, error: errorMessage };
    }
  }, [dispatch]);

  // ‚úèÔ∏è Create a new review (WITH BOOKING COORDINATION)
  const createReview = useCallback(async (reviewData: CreateReviewData) => {
    dispatch(setSubmitting(true));
    dispatch(clearError());

    try {
      console.log('‚úèÔ∏è useReviews: Creating new review...', reviewData);
      
      // 1Ô∏è‚É£ Create the review
      const newReview = await reviewsService.createReview(reviewData);
      
      // 2Ô∏è‚É£ Update local review state
      dispatch(addUserReview(newReview));
      
      // 3Ô∏è‚É£ üîÑ Cross-domain coordination: Update booking status to 'reviewed'
      const booking = findBookingByTourId(reviewData.tour);
      if (booking && booking.status === 'pending-review') {
        console.log(`üîÑ useReviews: Updating booking ${booking.id} status to 'reviewed'`);
        dispatch(updateUserBookingStatus({ 
          bookingId: booking.id, 
          status: 'reviewed' 
        }));
        
        // üîÑ Also update backend booking status
        try {
          // Import bookingsService if needed or call the API directly
          const { bookingsService } = await import('../services/bookingsService');
          await bookingsService.updateBookingStatus(booking.id, 'reviewed');
          console.log('‚úÖ useReviews: Successfully updated booking status in backend');
        } catch (bookingError) {
          console.warn('‚ö†Ô∏è useReviews: Failed to update booking status in backend:', bookingError);
          // Don't fail the whole operation, just log the warning
        }
      } else {
        console.log(`‚ÑπÔ∏è useReviews: No booking found or booking not in pending-review status for tour ${reviewData.tour}`);
      }
      
      // 4Ô∏è‚É£ If tour reviews are loaded, refresh them to show the new review
      if (reviewsState.tourReviews[reviewData.tour]) {
        console.log('üìÑ Refreshing tour reviews to include new review');
        dispatch(clearTourReviews(reviewData.tour));
        await loadTourReviews(reviewData.tour);
      }
      
      dispatch(setSubmitting(false));
      
      console.log('‚úÖ useReviews: Successfully created review and updated booking status');
      return { success: true, review: newReview };
      
    } catch (error) {
      console.error('üö® useReviews: Failed to create review:', error);
      
      const errorMessage = error instanceof ReviewsError 
        ? error.message 
        : 'Failed to create review. Please try again.';
        
      dispatch(setError(errorMessage));
      dispatch(setSubmitting(false));
      
      return { success: false, error: errorMessage };
    }
  }, [dispatch, reviewsState.tourReviews, loadTourReviews, findBookingByTourId]);

  // üìù Update an existing review
  const updateReview = useCallback(async (reviewId: string, updateData: UpdateReviewData) => {
    dispatch(setSubmitting(true));
    dispatch(clearError());

    try {
      console.log(`üìù useReviews: Updating review ${reviewId}...`, updateData);
      
      const updatedReview = await reviewsService.updateReview(reviewId, updateData);
      
      // Update in user reviews
      dispatch(updateUserReview(updatedReview));
      
      // Update current review if it's the same one
      if (reviewsState.currentReview?.id === reviewId) {
        dispatch(setCurrentReview(updatedReview));
      }
      
      // Refresh tour reviews if they're loaded
      if (reviewsState.tourReviews[updatedReview.tour]) {
        console.log('üìÑ Refreshing tour reviews after update');
        dispatch(clearTourReviews(updatedReview.tour));
        await loadTourReviews(updatedReview.tour);
      }
      
      dispatch(setSubmitting(false));
      
      console.log('‚úÖ useReviews: Successfully updated review');
      return { success: true, review: updatedReview };
      
    } catch (error) {
      console.error(`üö® useReviews: Failed to update review ${reviewId}:`, error);
      
      const errorMessage = error instanceof ReviewsError 
        ? error.message 
        : 'Failed to update review. Please try again.';
        
      dispatch(setError(errorMessage));
      dispatch(setSubmitting(false));
      
      return { success: false, error: errorMessage };
    }
  }, [dispatch, reviewsState.currentReview, reviewsState.tourReviews, loadTourReviews]);

  // üóëÔ∏è Delete a review (WITH BOOKING COORDINATION)
  const deleteReview = useCallback(async (reviewId: string) => {
    dispatch(setSubmitting(true));
    dispatch(clearError());

    try {
      console.log(`üóëÔ∏è useReviews: Deleting review ${reviewId}...`);
      
      // 1Ô∏è‚É£ Find the review to get tour ID before deletion
      const reviewToDelete = reviewsState.userReviews.find(r => r.id === reviewId);
      
      if (!reviewToDelete) {
        throw new ReviewsError('Review not found in local state');
      }
      
      // 2Ô∏è‚É£ Delete the review
      await reviewsService.deleteReview(reviewId);
      
      // 3Ô∏è‚É£ Remove from user reviews
      dispatch(removeUserReview(reviewId));
      
      // 4Ô∏è‚É£ üîÑ Cross-domain coordination: Update booking status back to 'pending-review'
      const booking = findBookingByTourId(reviewToDelete.tour);
      if (booking && booking.status === 'reviewed') {
        console.log(`üîÑ useReviews: Updating booking ${booking.id} status back to 'pending-review'`);
        dispatch(updateUserBookingStatus({ 
          bookingId: booking.id, 
          status: 'pending-review' 
        }));
        
        // üîÑ Also update backend booking status
        try {
          const { bookingsService } = await import('../services/bookingsService');
          await bookingsService.updateBookingStatus(booking.id, 'pending-review');
          console.log('‚úÖ useReviews: Successfully updated booking status in backend');
        } catch (bookingError) {
          console.warn('‚ö†Ô∏è useReviews: Failed to update booking status in backend:', bookingError);
          // Don't fail the whole operation, just log the warning
        }
      } else {
        console.log(`‚ÑπÔ∏è useReviews: No booking found or booking not in reviewed status for tour ${reviewToDelete.tour}`);
      }
      
      // 5Ô∏è‚É£ Clear current review if it's the same one
      if (reviewsState.currentReview?.id === reviewId) {
        dispatch(clearCurrentReview());
      }
      
      // 6Ô∏è‚É£ Refresh tour reviews if they're loaded
      if (reviewsState.tourReviews[reviewToDelete.tour]) {
        console.log('üìÑ Refreshing tour reviews after deletion');
        dispatch(clearTourReviews(reviewToDelete.tour));
        await loadTourReviews(reviewToDelete.tour);
      }
      
      dispatch(setSubmitting(false));
      
      console.log('‚úÖ useReviews: Successfully deleted review and updated booking status');
      return { success: true };
      
    } catch (error) {
      console.error(`üö® useReviews: Failed to delete review ${reviewId}:`, error);
      
      const errorMessage = error instanceof ReviewsError 
        ? error.message 
        : 'Failed to delete review. Please try again.';
        
      dispatch(setError(errorMessage));
      dispatch(setSubmitting(false));
      
      return { success: false, error: errorMessage };
    }
  }, [dispatch, reviewsState.userReviews, reviewsState.currentReview, reviewsState.tourReviews, loadTourReviews, findBookingByTourId]);

  // üîÑ Refresh operations
  const refreshTourReviews = useCallback(async (tourId: string) => {
    console.log(`üîÑ useReviews: Refreshing reviews for tour ${tourId}...`);
    dispatch(clearTourReviews(tourId));
    return await loadTourReviews(tourId);
  }, [dispatch, loadTourReviews]);

  const refreshUserReviews = useCallback(async () => {
    console.log('üîÑ useReviews: Refreshing user reviews...');
    dispatch(setUserReviews([]));
    return await loadUserReviews();
  }, [dispatch, loadUserReviews]);

  // üéØ Data getters with tour info enhancement
  const getTourReviews = useCallback((tourId: string): Review[] => {
    return reviewsState.tourReviews[tourId] || [];
  }, [reviewsState.tourReviews]);

  const getUserReviewsWithTourInfo = useCallback((): ReviewWithTourInfo[] => {
    return reviewsState.userReviews.map(review => {
      // Find tour info from tours state
      const tourInfo = toursState.allTours.find(tour => tour.id === review.tour);
      
      if (tourInfo) {
        return {
          ...review,
          tourInfo: {
            id: tourInfo.id,
            name: tourInfo.name,
            slug: tourInfo.slug,
            imageCover: tourInfo.imageCover
          }
        };
      }
      
      // If tour info not found, return review with undefined tourInfo
      return {
        ...review,
        tourInfo: {
          id: review.tour,
          name: 'Unknown Tour',
          slug: '',
          imageCover: 'default-tour.jpg'
        }
      };
    });
  }, [reviewsState.userReviews, toursState.allTours]);

  // üîß Helper functions
  const hasUserReviewedTour = useCallback((tourId: string): boolean => {
    return reviewsState.userReviews.some(review => review.tour === tourId);
  }, [reviewsState.userReviews]);

  const clearReviewsError = useCallback(() => {
    dispatch(clearError());
  }, [dispatch]);

  const selectReview = useCallback((review: Review) => {
    dispatch(setCurrentReview(review));
  }, [dispatch]);

  const clearSelectedReview = useCallback(() => {
    dispatch(clearCurrentReview());
  }, [dispatch]);

  return {
    // üìä State
    tourReviews: reviewsState.tourReviews,
    userReviews: reviewsState.userReviews,
    currentReview: reviewsState.currentReview,
    isLoading: reviewsState.isLoading,
    isSubmitting: reviewsState.isSubmitting,
    error: reviewsState.error,
    
    // üìñ Data Loading
    loadTourReviews,          // Tour Detail Page
    loadUserReviews,          // User Profile Page
    refreshTourReviews,
    refreshUserReviews,
    
    // ‚úèÔ∏è CRUD Operations (üîÑ WITH BOOKING COORDINATION)
    createReview,             // Also updates booking status to 'reviewed'
    updateReview,
    deleteReview,             // Also updates booking status to 'pending-review'
    
    // üéØ Data Getters
    getTourReviews,           // Ëé∑Âèñ tour ÁöÑ reviews
    getUserReviewsWithTourInfo, // Ëé∑ÂèñÁî®Êà∑ÁöÑ reviewsÔºàÂ∏¶ tour ‰ø°ÊÅØÔºâ

    // üîß Helper Functions
    hasUserReviewedTour,      // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤ËØÑËÆ∫ËøáÊüê‰∏™ tour
    selectReview,
    clearSelectedReview,
    clearError: clearReviewsError,
  };
};